"""File operation tools for the AI Coding Agent.

These tools provide safe file access within the current working directory.
All operations include path validation, security checks, and comprehensive logging.
"""

import os
from pathlib import Path
from typing import Optional
from pydantic import BaseModel, Field, field_validator
from langchain.tools import BaseTool

from ...config.settings import settings
from ...utils.logging import file_ops_logger


# Current working directory - all paths must be within this directory
CWD = Path.cwd().resolve()


class FileOperationError(Exception):
    """Base exception for file operation errors."""
    pass


class PathValidationError(FileOperationError):
    """Exception raised when path validation fails."""
    pass


class FileSizeError(FileOperationError):
    """Exception raised when file size exceeds limit."""
    pass


def validate_path(path_str: str, must_exist: bool = True) -> Path:
    """Validate and resolve a file path to ensure it's safe.

    Security checks:
    - Path must be within current working directory
    - No path traversal attacks (../)
    - No symlinks pointing outside CWD
    - File must exist (if must_exist=True)
    - File must be readable

    Args:
        path_str: Path string to validate
        must_exist: Whether the path must exist (default: True)

    Returns:
        Path: Validated and resolved Path object

    Raises:
        PathValidationError: If validation fails
    """
    # Check for empty or whitespace-only strings
    if not path_str or not path_str.strip():
        raise PathValidationError("Path cannot be empty")

    try:
        # Convert to Path and resolve (resolves symlinks and ..)
        path = Path(path_str).expanduser().resolve()

        # Check if path is within CWD
        try:
            path.relative_to(CWD)
        except ValueError:
            raise PathValidationError(
                f"Access denied: Path '{path_str}' is outside current working directory. "
                f"Only files within {CWD} can be accessed."
            )

        # Check if path exists
        if must_exist and not path.exists():
            raise PathValidationError(f"Path does not exist: {path_str}")

        # If it's a symlink, ensure target is also within CWD
        if path.is_symlink():
            real_path = path.resolve()
            try:
                real_path.relative_to(CWD)
            except ValueError:
                raise PathValidationError(
                    f"Access denied: Symlink '{path_str}' points outside current working directory"
                )

        # Check if path is readable (only if it exists)
        if must_exist and not os.access(path, os.R_OK):
            raise PathValidationError(f"Permission denied: Cannot read {path_str}")

        return path

    except (OSError, RuntimeError) as e:
        raise PathValidationError(f"Invalid path '{path_str}': {str(e)}")


def check_file_size(path: Path, max_size_mb: Optional[int] = None) -> None:
    """Check if file size is within limits.

    Args:
        path: Path to check
        max_size_mb: Maximum file size in MB (default: from settings)

    Raises:
        FileSizeError: If file is too large
    """
    if max_size_mb is None:
        max_size_mb = settings.MAX_FILE_SIZE_MB

    max_size_bytes = max_size_mb * 1024 * 1024
    file_size = path.stat().st_size

    if file_size > max_size_bytes:
        size_mb = file_size / (1024 * 1024)
        raise FileSizeError(
            f"File too large: {size_mb:.2f}MB (max: {max_size_mb}MB). "
            f"Consider reading the file in chunks or increasing MAX_FILE_SIZE_MB."
        )


def read_file_content(path: Path) -> str:
    """Read file content with encoding fallback.

    Args:
        path: Path to read

    Returns:
        str: File content

    Raises:
        FileOperationError: If reading fails
    """
    # Try UTF-8 first
    try:
        return path.read_text(encoding='utf-8')
    except UnicodeDecodeError:
        file_ops_logger.warning(f"UTF-8 decode failed for {path}, trying latin-1")
        try:
            return path.read_text(encoding='latin-1')
        except Exception as e:
            raise FileOperationError(f"Failed to read file with encoding fallback: {str(e)}")
    except Exception as e:
        raise FileOperationError(f"Failed to read file: {str(e)}")


# ============================================================================
# ReadFile Tool
# ============================================================================

class ReadFileInput(BaseModel):
    """Input schema for read_file tool."""

    path: str = Field(
        description="Path to the file to read (relative or absolute, must be within current directory)"
    )

    @field_validator('path')
    @classmethod
    def validate_path_field(cls, v: str) -> str:
        """Validate path field."""
        if not v or not v.strip():
            raise ValueError("Path cannot be empty")
        return v.strip()


class ReadFileTool(BaseTool):
    """Tool to read file contents safely.

    Security features:
    - Path validation (must be within CWD)
    - File size limits
    - Encoding fallback (UTF-8 -> latin-1)
    - Comprehensive logging
    """

    name: str = "read_file"
    description: str = (
        "Read the contents of a file. "
        "Input should be a file path (relative or absolute). "
        "The file must be within the current working directory. "
        "Returns the file contents as a string."
    )
    args_schema: type[BaseModel] = ReadFileInput

    def _run(self, path: str) -> str:
        """Execute the read_file operation.

        Args:
            path: Path to the file to read

        Returns:
            str: File contents or error message
        """
        try:
            # Validate path
            validated_path = validate_path(path, must_exist=True)

            # Check if it's a file (not a directory)
            if not validated_path.is_file():
                error_msg = f"Error: '{path}' is not a file"
                file_ops_logger.error(error_msg)
                return error_msg

            # Check file size
            check_file_size(validated_path)

            # Read file content
            content = read_file_content(validated_path)

            # Log successful operation
            file_ops_logger.info(
                f"READ: {validated_path} "
                f"(size: {validated_path.stat().st_size} bytes, "
                f"lines: {len(content.splitlines())})"
            )

            return content

        except PathValidationError as e:
            error_msg = f"Path validation error: {str(e)}"
            file_ops_logger.error(error_msg)
            return error_msg

        except FileSizeError as e:
            error_msg = f"File size error: {str(e)}"
            file_ops_logger.error(error_msg)
            return error_msg

        except FileOperationError as e:
            error_msg = f"File operation error: {str(e)}"
            file_ops_logger.error(error_msg)
            return error_msg

        except Exception as e:
            error_msg = f"Unexpected error reading file: {str(e)}"
            file_ops_logger.exception(error_msg)
            return error_msg

    async def _arun(self, path: str) -> str:
        """Async version (not implemented, falls back to sync)."""
        return self._run(path)


# ============================================================================
# ListDirectory Tool
# ============================================================================

class ListDirectoryInput(BaseModel):
    """Input schema for list_directory tool."""

    path: str = Field(
        default=".",
        description="Path to the directory to list (default: current directory)"
    )

    @field_validator('path')
    @classmethod
    def validate_path_field(cls, v: str) -> str:
        """Validate path field."""
        if not v or not v.strip():
            return "."  # Default to current directory
        return v.strip()


class ListDirectoryTool(BaseTool):
    """Tool to list directory contents safely.

    Security features:
    - Path validation (must be within CWD)
    - Shows file metadata (size, type, modified time)
    - Formatted output for easy reading
    - Comprehensive logging
    """

    name: str = "list_directory"
    description: str = (
        "List the contents of a directory. "
        "Input should be a directory path (default: current directory). "
        "Returns a formatted list of files and directories with metadata "
        "(name, type, size, modified time)."
    )
    args_schema: type[BaseModel] = ListDirectoryInput

    def _format_size(self, size_bytes: int) -> str:
        """Format file size in human-readable format.

        Args:
            size_bytes: Size in bytes

        Returns:
            str: Formatted size (e.g., "1.5 KB", "2.3 MB")
        """
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.1f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f} TB"

    def _format_time(self, timestamp: float) -> str:
        """Format timestamp in readable format.

        Args:
            timestamp: Unix timestamp

        Returns:
            str: Formatted time (e.g., "2024-01-15 14:30")
        """
        from datetime import datetime
        dt = datetime.fromtimestamp(timestamp)
        return dt.strftime("%Y-%m-%d %H:%M")

    def _run(self, path: str = ".") -> str:
        """Execute the list_directory operation.

        Args:
            path: Path to the directory to list

        Returns:
            str: Formatted directory listing or error message
        """
        try:
            # Handle empty or whitespace-only paths (default to current directory)
            if not path or not path.strip():
                path = "."

            # Validate path
            validated_path = validate_path(path, must_exist=True)

            # Check if it's a directory
            if not validated_path.is_dir():
                error_msg = f"Error: '{path}' is not a directory"
                file_ops_logger.error(error_msg)
                return error_msg

            # Get directory contents
            entries = []
            try:
                for entry in sorted(validated_path.iterdir(), key=lambda x: (not x.is_dir(), x.name.lower())):
                    try:
                        stat = entry.stat()
                        entry_info = {
                            'name': entry.name,
                            'type': 'DIR' if entry.is_dir() else 'FILE',
                            'size': self._format_size(stat.st_size) if entry.is_file() else '-',
                            'modified': self._format_time(stat.st_mtime),
                        }
                        entries.append(entry_info)
                    except (OSError, PermissionError) as e:
                        # Skip entries we can't access
                        file_ops_logger.warning(f"Cannot access {entry}: {e}")
                        continue

            except PermissionError as e:
                error_msg = f"Permission denied: Cannot list directory '{path}'"
                file_ops_logger.error(error_msg)
                return error_msg

            # Format output
            if not entries:
                result = f"Directory '{path}' is empty."
            else:
                # Create formatted output
                lines = [f"Contents of '{validated_path.relative_to(CWD) if validated_path != CWD else '.'}':\n"]
                lines.append(f"{'Name':<40} {'Type':<6} {'Size':<12} {'Modified':<20}")
                lines.append("-" * 80)

                for entry in entries:
                    lines.append(
                        f"{entry['name']:<40} {entry['type']:<6} "
                        f"{entry['size']:<12} {entry['modified']:<20}"
                    )

                # Add summary
                file_count = sum(1 for e in entries if e['type'] == 'FILE')
                dir_count = sum(1 for e in entries if e['type'] == 'DIR')
                lines.append("-" * 80)
                lines.append(f"Total: {file_count} file(s), {dir_count} directory(ies)")

                result = "\n".join(lines)

            # Log successful operation
            file_ops_logger.info(
                f"LIST: {validated_path} "
                f"(found {len(entries)} entries)"
            )

            return result

        except PathValidationError as e:
            error_msg = f"Path validation error: {str(e)}"
            file_ops_logger.error(error_msg)
            return error_msg

        except FileOperationError as e:
            error_msg = f"File operation error: {str(e)}"
            file_ops_logger.error(error_msg)
            return error_msg

        except Exception as e:
            error_msg = f"Unexpected error listing directory: {str(e)}"
            file_ops_logger.exception(error_msg)
            return error_msg

    async def _arun(self, path: str = ".") -> str:
        """Async version (not implemented, falls back to sync)."""
        return self._run(path)


# ============================================================================
# Tool Factory Functions
# ============================================================================

def get_read_file_tool() -> ReadFileTool:
    """Get an instance of the ReadFile tool.

    Returns:
        ReadFileTool: Configured read file tool
    """
    return ReadFileTool()


def get_list_directory_tool() -> ListDirectoryTool:
    """Get an instance of the ListDirectory tool.

    Returns:
        ListDirectoryTool: Configured list directory tool
    """
    return ListDirectoryTool()
